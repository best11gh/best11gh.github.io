---
title:  "[파이썬/Python] 백준 1463번 1로 만들기"
excerpt: 동적 계획법, 이분 탐색
categories:
  - BOJ

toc: true
toc_sticky: true
 
date: 2022-08-09
last_modified_at: 2022-08-09
---
## 문제

<https://www.acmicpc.net/problem/1463>


![백준 1463번](https://user-images.githubusercontent.com/81560908/183637022-7fcc6019-b34b-4b9e-ae4a-ae7566ff7e99.png)


## 답안

```python
n = int(input())
# 배열 만들어두기
d=[0]*(n+1)

for i in range(2, n+1):
    d[i] = d[i-1] + 1
    if i%3==0:
        d[i] = min(d[i], d[i//3]+1)
    if i%2==0:
        d[i] = min(d[i], d[i//2]+1)
        
print(d[n])
```


## 풀이

처음에는 while True와 if문을 사용하려고 했지만, 시간초과가 떴음. 백준 오류에 대해 찾아보다 시간을 줄이는 알고리즘에는 대표적으로 동적 계획법, 이분 탐색 등이 있다는 것을 알게 돼서 두 개에 대해 알아봄


### 동적 계획법(DP)

- 보통 특정 데이터 내 최대화/최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.

#### 사용 조건
- 동일한 작은 문제들이 반복하여 나타나는 경우
- 부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우

#### 사용 방법
1. 문제의 변수 파악  

2. 변수 간 관계식 (점화식) 만들기

3. 변수의 값에 따른 결과를 저장 (Memoization)

    - 변수 값에 따른 결과를 저장할 배열 등을 미리 만들고 그 결과를 나올 때마다 배열 내에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다.

4. 기저 상태 파악하기
    - 가장 작은 문제의 상태를 알아야한다.
    - ex) 피보나치 수열의 경우 f(0) = 0, f(1) = 1과 같은 방식

5. 구현하기

#### 구현 방법

##### Bottom-Up 방식

- 아래에서부터 계산을 수행하고 누적시켜서 전체 큰 문제를 해결하는 방식
- 이 경우, Memoization이 아니라 Tabulation이라 함.

##### Top-Down 방식

- 위에서 부터 바로 호출을 시작하여 dp[0]의 상태까지 내려간 다음 해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식

### 이분 탐색(이진 탐색)

- 전체 데이터가 저장된 구간을 반으로 나누어 데이터가 저장된 위치를 찾아가는 방식

- 지속적으로 반으로 나누면서 탐색을 수행하므로 시간복잡도는 O(logn)

### 문제 풀이

```
d=[0]*(n+1)
```
- 변수 값에 따른 결과를 저장할 배열을 만드는 것
- n+1이 아니라 1000001이어도 가능하긴 함.

#### 변수 간 관계

d[1] = 0 이므로 for 문을 돌릴 때 2를 시작점으로 잡음.

```python
n = 2인 경우,  2 / 2 = 1  ➡  d[2] = 1 
n = 3인 경우,  3 / 3 = 1  ➡  d[3] = 1
n = 4인 경우,  4 / 2 ➡ 2 / 2 = 1  ➡  d[4] =2
n = 5인 경우,  5 - 1 ➡ 4 / 2 ➡ 2 / 2 = 1  ➡  d[5] = 3
n = 6인 경우,  6 / 3 ➡ 2 / 2 = 1  or  6 / 2 ➡ 3 / 3 = 1  ➡  d[6] = 2
n = 7인 경우,  7 - 1 ➡ 6 / 3 ➡ 2 / 2 = 1  or  7 - 1 ➡ 6 / 2 ➡ 3 / 3 = 1  ➡  d[7] = 3
```
위 연산들을 읽어보면 부분 문제가 보임

n = 7일 때 n에서 1을 빼고 나면 6이 되고, 그 뒤는 n = 6일 때와 같다.

이 것을 식으로 표현하면 d[7] = 1 + d[6]이 된다. 

n = 6인 경우, d[6] = 1+ d[6//2]   or  d[6] = 1 + d[6//3]

이럴 땐, 두 값을 비교해 더 작은 값을 d[6]에 삽입해주면 된다.
    

```python
for i in range(2, n+1):
    d[i] = d[i-1] + 1
    if i%3==0:
        d[i] = min(d[i], d[i//3]+1)
    if i%2==0:
        d[i] = min(d[i], d[i//2]+1)
```

그러면 이렇게 코드를 짤 수 있는데, 최솟값을 찾아야 하므로 둘 다 if를 써야 한다.